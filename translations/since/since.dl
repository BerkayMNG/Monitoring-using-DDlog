
input stream Timestamp(tp:u32, ts:u32)
input stream P(tp:u32, id:u32)
input stream Q(tp:u32, id:u32)
input relation Intervall(min:u32, max:u32) 



//Auxiliary
//tp not needed anymore when not batched
relation Data_cached(ts:u32, id:u32)  //corresponds to data_in and Data_prev in SLW
relation Tuple_since(ts:u32, id:u32)

//output
output relation Satisfied(tp:u32, ts:u32, id:u32)



Data_cached(ts, id)         :- Q'(_,id), Timestamp'(_, ts). //since not batched just join without extra step- maybe faster
Data_cached(ts_old, id)     :- Data_cached-1(ts_old, id), Timestamp'(_, ts_new), Intervall(min,max),
                                ts_old <= ts_new, ts_new - ts_old <= max.

Tuple_since(ts,id)          :- Q'(_,id), Timestamp'(_, ts), not Tuple_since-1(_,id).
Tuple_since(ts,id)          :- Q'(_,id), Timestamp'(_, ts), Tuple_since-1(_,id), not P'(_,id).
Tuple_since(ts,id)          :- Tuple_since-1(ts,id), P'(_,id).

Satisfied(tp,ts_new,id)     :- Tuple_since(ts_old,id), Timestamp'(tp,ts_new), Intervall(min,max),
                                ts_old <= ts_new, ts_new - ts_old <= max, ts_new - ts_old >= min.
Satisfied(tp,ts,id)         :- Satisfied-1(tp,ts,id).







/**
input stream Timestamp(tp:u32, ts:u32)
input stream P(tp:u32, id:u32)
input stream Q(tp:u32, id:u32)
input relation Intervall(min:u32, max:u32) //more generic



//Auxiliary
relation P_cache(tp:u32,ts:u32,id:u32)
relation Q_cache(tp:u32,ts:u32,id:u32)
relation Tuple_chain(ap:u32,tp:u32,ts:u32,id:u32)


//output
output relation Satisfied(ap:u32, ts:u32, id:u32)



Q_cache(tp_old,ts_old,id) :- Timestamp'(tp_new,ts_new), Q_cache-1(tp_old,ts_old,id), Intervall(min,max), tp_new - ts_old <= max. 
Q_cache(tp,ts,id) :- Timestamp'(tp,ts), Q'(tp,id).

P_cache(tp_new-1,ts_old,id) :- Timestamp'(tp_new,ts_new), P_cache-1(tp_new-1,ts_old,id), Intervall(min,max), tp_new - ts_old <= max.
P_cache(tp,ts,id) :- Timestamp'(tp,ts), P'(tp,id).


Tuple_chain(tp_new-1,tp_old,ts_old,id) :- Timestamp'(tp_new,ts_new), Tuple_chain-1(tp_new-1,tp_old,ts_old,id),
                                            Intervall(min,max), ts_new - ts_old <= max.
Tuple_chain(tp_new,tp_new,ts_new,id) :- Timestamp'(tp_new,ts_new), Q'(tp_new,id).
Tuple_chain(tp_new,tp_old,ts_old,id) :- Timestamp'(tp_new,ts_new), P'(tp_new,id), Tuple_chain(tp_new-1,tp_old,ts_old,id),
                                        Intervall(min,max), ts_new-ts_old <= max.



Satisfied(ap,ts_new,id) :- Satisfied-1(ap,ts_new,id).
Satisfied(ap,ts_new,id) :- Tuple_chain(ap,tp,ts,id), Timestamp'(ap,ts_new), Intervall(min,max), ts_new - ts <= max, ts_new - ts >= min.

*/